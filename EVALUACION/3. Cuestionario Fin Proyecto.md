# Cuestionario de Evaluación del Proyecto

**Nombre del Proyecto:** IBERASI  

**Miembros del Equipo:**  

- Esther Espejo Lucena  
- Salvador Del Marmol Rodriguez  
- Juan Carlo Flores Flores  
- Fco. Jesús Castillo Celis

**Fecha de Evaluación:**

---

### I. Descripción General del Proyecto

1. **Tipo de Proyecto:**

    - **Describid brevemente la aplicación que habéis desarrollado.**  

        Hemos desarrollado *Triviados*, un juego de preguntas y respuestas con muchas temáticas donde los usuarios pueden competir por puntos, además tienen vidas limitadas y pueden consultar el ranking general. El sistema elige aleatoriamente la temática mediante una ruleta, y el jugador responde preguntas con un tiempo contrarreloj.

    - **¿Qué funcionalidades principales ofrece?**  

        - Sistema de autenticación con tokens (JWT).  
        - Ruleta de temáticas aleatoria.  
        - Preguntas con tiempo límite.  
        - Ranking Global y Ranking de las mejores 5 partidas.  
        - Sonido y efectos visuales (confetti, animaciones).  
        - Modo Responsive.  
        - Interfaz visual según la temática.  
        - Ayuda de un personaje que actúa como comodín.
        - Visualización de los jugadores activos ordenados por su puntuación en tiempo real.

    - **¿Cómo se compone el frontend y el backend de vuestra aplicación?**  

    - **Backend**: Desarrollado con ASP.NET Core. Gestiona usuarios, preguntas y respuestas, rankings y partidas mediante endpoints RESTful.  
    - **Frontend**: Desarrollado con Vite + React con Typescript. Usamos TailwindCSS como framework de estilos, Framer Motion para animaciones, y Axios para peticiones al backend.

    - **¿Qué motor de base de datos habéis utilizado y por qué?**  

        Hemos utilizado **SQL Server** como motor de base de datos. Lo elegimos porque se integra fácilmente con .NET, también porque ofrece buen rendimiento.

2. **Idea de Aplicación (si aplica):**

    - **¿En cuál de las ideas de aplicación propuestas os habéis basado?**  
    Nos hemos basado en la idea de desarrollar una aplicación de entretenimiento, sobre todo en un juego de preguntas tipo trivial.

    - **Si habéis desarrollado una idea propia, describidla brevemente y justificad vuestra elección.**  
    Aunque la base es un trivial clásico, le hemos añadido elementos propios que lo convierten en un trivial único, como los personajes y la ruleta, esto hace que sea una experiencia única.  
    Nosotros hemos elegido hacer esto porque nos gustaba la idea de hacer una aplicación entretenida, que cualquiera pudiera jugar fácilmente y que el juego resulte tan entretenido que los usuarios quieran volver a jugar.

---

### II. Gestión del Proyecto y Metodología

1. **Trabajo en Equipo y Colaboración:**
    - **¿Cómo habéis organizado el trabajo en equipo?**

        Al inicio del proyecto asignamos ciertos roles como **Scrum Master**, responsable de **DevOps** o **Developers**, sin diferenciar entre Frontend Developer y Backend devolopers. Sin embargo, todos los miembros del equipo hemos desarrollado roles de Developers, tanto en el Frontend como en el Backend, ya que la idea inicial del equipo era realizar una rotación de tareas para garantizar el aprendizaje de ambos campos, Frontend y Backend.

        Cada miembro del equipo ha tenido asignadas ciertas tareas tras mutuo acuerdo, fomentando la polivalencia y la ayuda mutua. En algunos casos, dado que las tecnologías usadas eran nuevas para el equipo, se han realizado tareas entre dos miembros abriendo dos líneas de investigación para obtener la mejor solución posible.
        Se han realizado reuniones regulares para planificar, revisar y resolver obstáculos, lo que nos permitió mantener una visión común, un buen ritmo de trabajo y resolver obstáculos entre todos.

    - **¿Qué herramientas o estrategias habéis utilizado para la colaboración?**

        Par la colaboración hemos usado varias herramientas como: los boards de **Azure DevOps**, para la definición, asignación y revisión de objetivos y tareas; la herramienta **Teams** para establecer reuniones periódicas, compartir información relevante en las carpetas compartidas y como herramienta de comunicación; los repositorios **Git** para el trabajo colaborativo, permitiendo el trabajar en paralelo y gestionar los cambios sin conflictos.
        A todo esto, habría que añadir la comunicación continua en persona entre los miembros del equipo para pequeñas dudas y ayuda mutua.

2. **Metodologías Ágiles:**
    - **¿Qué metodologías ágiles habéis implementado (Scrum, Kanban, etc.)?**

        Hemos implementado metodologías ágiles **Scrum**, estructurando el proyecto en ciclos cortos e iterativos (**Sprints**) basados en la entrega de valor al cliente, presentando ciertas funcionalidades o módulos funcionales.  

    - **Describid brevemente cómo habéis llevado a cabo las iteraciones y entregas de valor.**

        Se decidió dividir el proyecto en Sprints de una semana, dado el carácter y amplitud del proyecto.

        Se definió un **Product Backlog** incluyendo todas las "historias de usuario" y elementos de trabajo que incluye el proyecto, para después ir asignando dichas historias de usuario a cada Sprint realizado.

        Al inicio de cada Sprint se ha realizado un **Sprint Planning**  para definir y asignar los Sprint Backlog de dicho Sprint y asignar tareas a cada miembro. Diariamente se han realizado **Daily Scrum** (15 minutos) para revisar el  estado de los backlogs e identificar bloqueos y adaptaciones necesarias.

        Al final del Sprint se ha organizado un **Sprint Review** (30 minutos) para  presentar a los skateholders la entrega de valor del producto realizada y obtener feedback con posibles mejoras u orientaciones sobre las expectativas y necesidades del cliente. Del mismo modo, se ha realizado una **Sprint  Retrospective** (30 minutos) para evaluar el trabajo en equipo y establecer  mejoras.  

---

### III. Requerimientos Técnicos

1. **Arquitectura:**
    - **Describid la arquitectura general de vuestra aplicación (ej. Monolítica, Microservicios, MVC, MVVM, DDD, capas, etc.).**

        Nuestra aplicación utiliza una arquitectura basada en Domain-Driven Design (DDD), enfocada en una estructura por capas que separa claramente las responsabilidades del dominio, la aplicación, la infraestructura y la interfaz de usuario (Web API).

    - **Justificad la elección de esta arquitectura en relación con el tipo de proyecto desarrollado.**

        Inicialmente, contemplamos usar un patrón MVC, pero tras revisar los requisitos del proyecto y la necesidad de escalar adecuadamente el sistema, optamos por DDD. Esta arquitectura nos permite una mayor claridad en la lógica de negocio, facilita el mantenimiento y mejora la escalabilidad, lo cual es crucial para una API modular y extensible como la nuestra.

    - **Describid la estructura de carpetas elegida para el proyecto.**
        ```Text
        IberAsi/
        ├── Docs/
        │   ├── Diagramas/
        │   └── Imagenes/
        ├── Backend/
        │   └── src/
        │       ├── Ble.Triviados.Application/
        │       │   ├── Dtos/
        │       │   ├── Interfaces/
        │       │   └── Services/
        │       ├── Ble.Triviados.Domain.Entity/
        │       │   ├── Entity/
        │       │   └── Interfaces/
        │       ├── Ble.Triviados.Infrastructure.Persistence/
        │       │   ├── Migrations/
        │       │   ├── Repositories/
        │       │   └── Seeders/
        │       ├── Ble.Triviados.Services.WebApi/
        │       │   ├── Controllers/
        │       │   ├── Helpers/
        │       │   ├── Properties/
        │       │   └── SeedData/
        │       └── Ble.Triviados.UnitTest/
        │           ├── Aplicacion/
        │           ├── Components/
        │           ├── Dominio/
        │           ├── Infraestructura/
        │           └── WebAPI/
        ├── Frontend/
        │   └── src/
        │       └── App-React/
        │           ├── node_modules/
        │           ├── public/
        │           │   ├── personajes/
        │           │   └── sonidos/
        │           └── src/
        │               ├── asset/
        │               ├── component/
        │               │   ├── home/
        │               │   ├── juego/
        │               │   ├── layout/
        │               │   └── ui/
        │               └── pages/  
        ```

2. **Backend:**
    - **¿Qué lenguaje/framework habéis utilizado para el backend? ¿Seguisteis la recomendación de .NET (C#)? En caso contrario, ¿por qué?**

        Para el desarrollo del backend utilizamos C# con el framework ASP.NET Core 9, siguiendo la recomendación de utilizar el ecosistema .NET proporcionado por Microsoft. Esta elección nos permitió trabajar de forma eficiente y mantener una fuerte cohesión con otras tecnologías del proyecto, como SQL Server y Azure.

    - **¿Cómo habéis implementado los test unitarios en el backend? Mostrad ejemplos.**

        En nuestra aplicación para los test unitarios hemos utilizado XUnit y Moq para realizar mocks de dependencias. Y para facilitar las aserciones, utilizamos FluentAssertions.
        Hemos añadido a nuestra solución un proyecto Razor e instalado las depedencias necesarias via NuGet:

            - Microsoft.NET.Test.Sdk
            - xunit
            - xunit.runner.visualstudio
            - FluentAssertions
            - Moq

        Ejemplos de **Test en Backend**:

            (Retorna mensaje de error cuando nombre o contraseña son invalidos)

            public async Task RegistrarUsuarioAsync_DeberiaRetornarMensajeError_CuandoNombreOContrasenaInvalidos(string nombre, string password)
            {
                // Arrange
                var dto = new RegistroUsuarioDto
                {
                    Name = nombre,
                    Password = password
                };

                var mockRepo = new Mock<IUsuarioRepository>();
                var configurationMock = new Mock<IConfiguration>();
                var service = new UsuarioService(mockRepo.Object, configurationMock.Object);

                // Act
                var resultado = await service.RegistrarUsuarioAsync(dto);

                // Assert
                resultado.Should().Be("Nombre o contraseña no válidos.");
            }

3. **Frontend:**
    - **¿Qué framework o librería habéis utilizado para el frontend? ¿Seguisteis la recomendación de React? En caso contrario, ¿por qué?**

        En frontend utilizamos React como framework, desarrollando la aplicación con TypeScript

    - **Confirmad el uso de TypeScript en el frontend. ¿Qué ventajas o desafíos encontrasteis?**

        Confirmamos el uso de **TypeScript en el frontend**.

        Ventajas de usar TypeScript:

            - **Tipado estático**, lo que ayuda a detectar errores en tiempo de compilación.

            - **Mejor soporte para herramientas de desarrollo** como autocompletado y refactorización.

            - **Código más mantenible y escalable**.

        Desafios encontrados al utilizar TypeScript:

            - Mayor difucultad en el aprendizaje para comprender las **tipificaciones complejas**.

            - Necesidad de **configurar** correctamente tipos personalizados en **bibliotecas de terceros**.

    - **¿Cómo habéis implementado los test unitarios en el frontend? Mostrad ejemplos.**

        Para el testing en frontend, empleamos Vitest, un framework moderno y rápido compatible con Vite, que facilita el testing en proyectos de React con TypeScript.

        Ejemplos de **Test en Frontend**:

         (Muestra error si las contraseñas no coinciden)

          it('muestra error si las contraseñas no coinciden', () => {
            renderWithRouter(<Register />);
            fireEvent.change(screen.getByPlaceholderText('Nombre de usuario'), {
            target: { value: 'Carlos' },
            });
            fireEvent.change(screen.getByPlaceholderText('Contraseña'), {
            target: { value: '123' },
            });
            fireEvent.change(screen.getByPlaceholderText('Confirmar contraseña'), {
            target: { value: '456' },
            });
            fireEvent.click(screen.getByRole('button', { name: /registrarse/i }));

            expect(screen.getByText(/las contraseñas no coinciden/i)).toBeInTheDocument();
            });

4. **Base de Datos:**
    - **¿Habéis utilizado una base de datos SQL o NoSQL? Especificad cuál.**

        Utilizamos una base de datos SQL, concretamente Microsoft SQL Server.

    - **Justificad la elección de este tipo y motor de base de datos.**

        Dado que nuestra aplicación está **desarrollada con el stack de Microsoft (C#, ASP.NET Core)**, optar por SQL Server **facilitó la integración** mediante Entity Framework Core, permitiendo gestionar migraciones, modelos y consultas de forma eficaz. Además, garantiza rendimiento, escalabilidad y soporte empresarial.

5. **Despliegue:**
    - **¿En cuántos entornos habéis realizado despliegues (ej. desarrollo, preproducción, producción)? Describidlos.**

        El técnico DevOps de nuestro equipo se ha encargado de realizar el despliegue en el entorno de desarrollo utilizando **Azure DevOps**. La aplicación se ejecuta en **contenedores Docker** configurados mediante **Dockerfile** y desplegados a través de Pipelines CI/CD definidos en YAML.

            - Docker para contenerizar la aplicación.

            - Azure DevOps Pipelines para automatizar el despliegue.

            - Repositorios Git para el control de versiones y despliegue desde ramas.

        Hemos desplegado en entorno de **Desarrollo**, posteriormente en **Preproducción** y finalmente en entorno de **Producción**.

---

### IV. Calidad del Código y Buenas Prácticas

1. **Principios SOLID:**
    - **¿Cómo habéis aplicado los principios SOLID en vuestro código? Proporcionad ejemplos específicos de cada principio (o los que apliquen) en vuestro proyecto.**


   ### Principios SOLID en el Backend

    En el backend de nuestro proyecto **Triviados**,  hemos aplicado varios principio SOLID siguiendo la arquitectura DDD en .NET. A continuación, explicamos cómo:

    - **Principio de Responsabilidad Única (SRP)**:  
    Cada clase tiene una única función. Por ejemplo, `UsuarioService` se encarga únicamente de la lógica relacionada con los usuarios. El siguiente fragmento de código ilustra este principio:

        ```csharp
        public async Task<string> RegistrarUsuarioAsync(RegistroUsuarioDto dto)
        {
            // Validaciones básicas
            if (string.IsNullOrWhiteSpace(dto.Name) || string.IsNullOrWhiteSpace(dto.Password))
                return "Nombre o contraseña no válidos.";

            var nuevoUsuario = new Domain.Entity.Entities.Usuario
            {
                Name = dto.Name,
                Password = BCrypt.Net.BCrypt.HashPassword(dto.Password),
                Rol = "User",
                FechaRegistro = DateTime.Now
            };

            var usuarioCreado = await _usuarioRepository.RegistrarAsync(nuevoUsuario);
            return usuarioCreado != null ? "Usuario registrado correctamente." : "Error al registrar el usuario.";
        }
        ```

        Este método se ocupa únicamente del proceso de registro de un usuario.

    - **Principio de Abierto/Cerrado (OCP)**  
    Nuestro código está diseñado para **poder añadir nuevas funcionalidades sin modificar las ya existentes**. Un ejemplo es `PartidaAppService`, que gestiona la lógica de las partidas.

        Cuando añadimos el nuevo método `ObtenerTop5Async()`, que devuelve el top 5 de jugadores, no fue necesario modificar métodos existentes como `ObtenerRankingAsync()` o `ActualizarPartidaAsync()`.

        ```csharp
        public async Task<List<RankingItemDto>> ObtenerTop5Async()
        {
            var rankingCompleto = await _partidaRepository.ObtenerRankingGlobalAsync();

            var rankingTop5 = rankingCompleto
            .OrderByDescending(p => p.PuntosPartida)
            .Take(5)
            .Select((partida, index) => new RankingItemDto
            {
                Posicion = index + 1,
                NombreUsuario = partida.Usuario.Name,
                Puntos = partida.PuntosPartida,
                EsUsuarioActual = false,
                UsuarioId = partida.UsuarioId
            })
            .ToList();

        return rankingTop5;
        }
        ```  

    - **Principio de Sustitución de Liskov (LSP)**
    Para este principio usamos interfaces como `IPartidaRepository`, lo que permite **cambiar la clase que hace el trabajo real sin tener que modificar el resto del código**.

        Por ejemplo, el servicio `PartidaService` usa la interfaz `IPartidaRepository` para acceder a los datos. Gracias a esto, **podríamos sustituir la implementación concreta del repositorio por otra (por ejemplo, una versión en memoria para pruebas), sin que `PartidaAppService` deje de funcionar correctamente**.

        ```chshrap
        namespace Ble.Triviados.Domain.Entity.Interfaces
        {
            public interface IPartidaRepository
            {
                Task CrearPartidaAsync(Partida partida);
                Task<Partida?> ObtenerPorIdAsync(int id);
                Task ActualizarPartidaAsync(Partida partida);
                Task<List<(string Nombre, int Puntos)>> ObtenerTop10Async();
                Task<(int Posicion, int Puntos)?> ObtenerPosicionUsuarioAsync(int usuarioId);
                Task<List<Partida>> ObtenerRankingGlobalAsync();
                Task ObtenerPartidasPorUsuarioAsync(int usuarioId);
                Task<List<Partida>> ObtenerPartidasActivasAsync();
            }
        }  
        ```

        ```csharp
        public class PartidaAppService : IPartidaService
        {
            private readonly IPartidaRepository _partidaRepository;

            public PartidaAppService(IPartidaRepository partidaRepository)
                {
                    _partidaRepository = partidaRepository;
                }

            // ...
            public async Task<bool> ActualizarPartidaAsync(ActualizarPartidaDto dto)
            {
                var partida = await _partidaRepository.ObtenerPorIdAsync(dto.PartidaId);
                // ...
            }
        }
        ```  

    - **Principio de Segregación de Interfaces (ISP)**  
    En este principio lo cumplimos manteniendo nuestras interfaces **específicas y bien separadas por funcionalidad**.  
    Por ejemplo, la interfaz `IUsuarioService` define **solo dos métodos**, ambos relacionados con el usuario.

        ```csharp
            public interface IUsuarioService
            {
                Task<string> RegistrarUsuarioAsync(RegistroUsuarioDto dto);
                Task<string> LoginUsuarioAsync(LoginUsuarioDto dto);
            }
        ```

        Esto permite que cualquier clase que implemente esta interfaz solo tenga que encargarse de esos métodos, sin verse forzada a implementar lógica que no le corresponde.

    - **Principio de Inversión de Dependencias (DIP)**  
    En este principio, **los servicios dependen de abstracciones (interfaces), no de clases concretas**.

        Por ejemplo, `PartidaAppService` depende de `IParidaRepository`, y no de una clase específica. Esta dependencia se **inyecta desde fuera** mediante el contenedor de servicios de .NET.

        ```csharp
            // En PartidaAppService.cs
            public class PartidaAppService : IPartidaService
        { 
            private readonly IPartidaRepository _partidaRepository;

            public PartidaAppService(IPartidaRepository partidaRepository)
            {
                _partidaRepository = partidaRepository;
            }
        }
        ```  

        En **Program.cs** se configura esa dependencia.

        ```csharp
            builder.Services.AddScoped<IPartidaRepository, PartidaRepository>();
            builder.Services.AddScoped<IPartidaService, PartidaAppService>();
        ```  

 

   ### Principios SOLID en el Frontend

    En el frontend de **Triviados**, desarrollado con **React + TypeScript**, hemos aplicado varios principios SOLID adaptados al desarrollo de componentes y estructura moderna de interfaz.

    - **Principio de Responsabilidad Única (SRP)**  
    El componente `PreguntaCard` aplica perfectamente este principio porque se encarga únicamente de una cosa: **mostrar una pregunta al usuario y gestionar su respuesta**(correcta, incorrecta o por tiempo).  

        ```tsx
        const manejarRespuesta = (respuesta: string) => {
            if (respuestaSeleccionada !== null) return;

            const esCorrecta = respuesta === pregunta.respuestaCorrecta;
                setRespuestaSeleccionada(respuesta);
                setResultado(esCorrecta ? "correcto" : "incorrecto");

            if (esCorrecta) {
                sonidoAcierto.current?.play();
            } else {
                sonidoFallo.current?.play();
            }

            onRespuesta(esCorrecta, pregunta.tipo);
        };
        ```  

        Este método encapsula toda la lógica de gestión de respuesta: **verifica si es correcta, reproduce el sonido adecuado, y notifica al componente padre**. Todo esto forma parte del único propósito del componente.  

    - **Principio de Abierto/Cerrado (OCP)**  

        Este principio se aplica al componente reutilizable `ModalTematica`.  
        Está diseñado para **mostrar cualquier temática o mensaje sin tener que modificar su lógica interna**, simplemente cambiando las props(visible y tematica).  

        ```tsx
            interface ModalTematicaProps {
                visible: boolean;
                tematica: string | null;
            }
        ```  

        El modal **no está acoplado a una temática concreta**. Si queremos mostrar “Historia”, “Arte” o incluso usarlo en otro contexto (como mostrar una medalla o mensaje final), solo necesitamos cambiar las props, sin tocar el código interno del componente.  

    - **Principio de Sustitución de Liskov (LSP)**  
    Este principio indica que un componente debe poder ser sustituido por otro equivalente **sin romper el funcionamiento del sistema**.  

      Por ejemplo, el componente `Buttom` cumple con este principio.  

      ```tsx
            interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
                children: React.ReactNode;
                className?: string;
            }

            const Button = ({ children, className = '', ...props }: ButtonProps) => {
                return (
                    <button
                    {...props}
                    className={`bg-indigo-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-indigo-700 transition disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
                    >
                    {children}
                    </button>
                );
            };
      ```  

      Donde usemos este componente **`Button`**, podríamos cambiarlo por un `<button>` nativo o por otro botón personalizado que respete la misma interfaz de props, y todo seguiría funcionando sin romper el sistema.  

    - **Principio de Segregación de Interfaces (ISP)**

      Este principio indica que los componentes deben recibir solo la información que necesitan y **nada más**.  

      Por ejemplo, en `PreguntaCard.tsx` lo aplicamos definiendo tipos de props específicos:  

      ```tsx
        interface Props {
            pregunta: Pregunta;
            onRespuesta: (acertada: boolean, tipo: string, esTiempoAgotado?: boolean) => void;
            tiempoRestante: number;
            mensajeTiempo: boolean;
            forzarCorrecta?: boolean;
        }
      ```  

      Esta interfaz contiene **los campos que `PreguntaCard` necesita para funcionar**, y evita usar props genéricas o excesivas, lo que mejora la claridad y previene errores.  

    - **Principio de Inversión de Dependencias (DIP)**  

      Este principio lo aplicamos separando la **lógica del juego** de la **presentación visual**.  

      Por ejemplo, en **`Juego.tsx`** se encuentra la **lógica central** que gestiona la temática, estado de la partida, respuestas del jugador y ranking. Los componentes visuales (**`PreguntaCard`**, **`HeaderJuego`**, **`RankingPartidas`**, ...) reciben los datos y funciones como props, sin conocer la lógica que los genera.  

      ```tsx
        <PreguntaCard
            pregunta={preguntas[indiceActual]}
            onRespuesta={manejarRespuesta}
            tiempoRestante={tiempoRestante}
            mensajeTiempo={mostrarTiempoFinalizado}
            forzarCorrecta={forzarCorrecta}
        />
      ```  

      De esta forma, si quisiéramos cambiar cómo se calcula el tiempo o cómo se gestionan los puntos, **no sería necesario modificar `PreguntaCard`**, solo la lógica del componente principal.



2. **Estructuras de Datos y Patrones de Diseño:**
    - **Mencionad y describid algunas de las estructuras de datos clave que habéis utilizado y por qué fueron adecuadas.**  

        En **backend (ASP.NET Core + DDD)**:  
        - **Clases DTO** como `RegistroUsuarioDTO`, `ActualizarPartidaDto`, `PartidaEstadoDto`, etc.  
            - Se usan para **transportar datos entre capas**, sin exponer directamente las entidades al dominio.  
            - Son adecuados, ya que permiten **controlar qué datos en envían o reciben** y **validarlos con facilidad**.  

        - **Entidades de dominio** como `Usuario`, `Partida`, `Pregunta`:
            - Representan los datos del sistema.
            - Actualmente **no incluyen validaciones internas**, ya que estas se gestionan desde las capas de aplicación o mediante DTOs.  
            - Se diseñan principalmente con propiedades y constructores básicos, y son persistidas mediante EF Core.
            - La temática se gestiona como un campo dentro de `Pregunta`, no como entidad propia.  

        - **Listas y colecciones**:  
            - Se utilizan colecciones como `List<RankingItemDto>` para **almacenar resultados ordenados**, como rankings de usuarios, preguntas de una temática o partidas activas.  
            - Estas listas son ideales para recorrer, ordenar, filtrar o mapear los datos que luego se devuelven al frontend o se procesan en la lógica del juego.  
            - También se emplean en los **tests automatizados**, facilitando la simulación de resultados del backend (mocking) en controladores como PartidaController.  

        En **frontend (React + TypeScript)**:  
        - **Objetos tipados** en TypeScript como `Pregunta`.
            - Permiten escribir el código **más seguro y predecible**, sabiendo exactamente qué estructura tiene cada dato.  

            - Por ejemplo:  

                ```ts
                   type Pregunta = {
                        enunciado: string;
                        tipo: string;
                        respuestaCorrecta: string;
                        respuestasPregunta: string[];
                    };
                ```  

        - **Estados locales (`useState`) con arrys u objetos** para manejar el estado del juego:  

            ```ts  
                const [preguntas, setPreguntas] = useState<Pregunta[]>([]);
                const [estadoPartida, setEstadoPartida] = useState<EstadoPartida |  null>(null);
            ```  

            - Esto permite **gestionar dinámicamente la lógica del juego** en el cliente.

    - **¿Qué patrones de diseño habéis implementado en vuestro proyecto? Explicad su propósito y cómo los habéis utilizado.**

      ### Backend  

        - **DDD (Domain-Driven Desing)**  
            - Separa claramente la lógica del dominio, la aplicación, la infraestructura y la API.  
            - Ayuda a mantener el código organizado, reutilizable y testeable.  
        - **Repositorio** (`IPartidaRepository`, `IPreguntaRepository`, etc.)  
            - Separa el acceso a datos de la lógica de negocio.  
            - Permite cambiar la implementación de datos sin afectar al resto del sistema.  
        - **Inversión de Dependencias** (via `Program.cs`)  
            - La aplicación **depende de interfaces, no de implementaciones concretas**.  
            - Por ejemplo:  

            ```csharp  
                builder.Services.AddScoped<IPartidaRepository, PartidaRepository>();
            ```  

      ### Frontend  

        - **Composición de Componentes**  
            - La interfaz está divida en componentes reutilizables (`PreguntarCard`, `ModalTematica`, `RankingPartidas`, etc).  
            - Cada componente tiene una responsabilidad concreta y se combina desde `Juego.tsx`.  
        - **Separación de lógica y presentación**  
            - La lógica del juego está contenida en `Juego.tsx` o podría extraerse en un hook, mientras los componentes visuales solo reciben props.  
            - Facilita el testeo y el mantenimiento.  

---

### V. Control de Versiones y CI/CD

1. **Repositorio y Flujo de Trabajo:**
    - **Explicad vuestro proceso para subir cambios, incluyendo el uso de Pull Requests y Code Reviews.**

        Durante el desarrollo del proyecto, utilizamos **Git** como sistema de control de versiones, con un repositorio principal alojado en *AzureDevops*.

        Inicialmente, estructuramos las ramas en tres niveles:

        - `main`: rama estable para producción o entregas.
        - `developers`: rama intermedia para integración    continua.
        - `feature/*`: ramas específicas para nuevas    funcionalidades o partes del proyecto.

        Sin embargo, con el paso del tiempo **simplificamos el  flujo** para hacerlo más     ágil: mantuvimos solo la    rama `main`, desde la cual se creaban directamente     ramas   `feature/*`, y se gestionaban mediante Pull   Requests.

        Cada **Pull Request**:

        - Correspondía a una **historia de usuario completa** o     parte de ella si se     dividía en varias tareas.
        - Incluía al menos un **revisor asignado**  (*reviewer*), encargado de validar el    código antes    de fusionarse con `main`.
        - En algunos casos, más miembros del equipo colaboraban     para **resolver conflictos  o mejorar el código**.

        Esta estrategia nos permitió mantener un **flujo de     integración limpio**, fomentar  el trabajo colaborativo     y garantizar la calidad del código entregado.



2. **Mensajes de Confirmación (Commits):**
    - **¿Habéis utilizado Conventional Commits para los mensajes de confirmación o alguna alternativa? Mostrad ejemplos del historial de commits.**

        Aunque no seguimos estrictamente la convención  **Conventional Commits**, sí intentamos establecer una   **estructura clara y coherente** para nombrar:

        - Las ramas
        - Los Pull Requests
        - Los commits

        Intentamos usar un formato descriptivo basado en el     tipo de funcionalidad y el área del proyecto, aunque en     algunas ocasiones no se hayan aplicado estrictamente.   Algunos ejemplos:

        **Ramas:**

        Nombrando la palabra "feature" y seguida de "Frontend"  o "Backend", según lo que se haya desarrollado +     funcionalidad a desarrollar en la rama.
        Ejemplos:

        ```bash
            feature/Backend-Test Login
            feature/Backend-Migrations-Seeder
        ```

        **Pull Requests (PR):**

        Generalmente se ha usado el mismo nombre de la rama     creada asociada el Pull Request.
        Ejemplos:

        ```bash
            feature/Backend-Test Login
            feature/Backend-Migrations-Seeder
        ```

        **Commits:**

        El nombre de los commits ha sido más variado aunque en  algunos casos se ha intentado seguir el mismo esquema    que los nombres de las ramas.
        Ejemplos:

        ```bash
            feature/Backend-Migrations-Seeders-Connected  
            feature/Backend-Seeders-TodasPreguntas
            Actualizar y comprobar Juego.test.tsx
            Crear componente RankingPartidas.tsx
        ```

3. **CI/CD:**
    - **Describid cómo habéis implementado la Integración Continua (CI) y el Despliegue Continuo (CD).**
    - **¿Habéis utilizado Azure DevOps para los despliegues como se especificaba? En caso afirmativo, describid por encima las principales acciones de vuestro pipeline.**

        Hemos implementado un proceso completo de **Integración Continua (CI) y Despliegue Continuo (CD)** utilizando **Azure DevOps** como herramienta principal para la automatización.

        - **Pruebas locales**

            Antes de **configurar los pipelines**, probamos la aplicación **localmente** en Windows 11 usando WSL. Creamos y ejecutamos contenedores con **Dockerfile y docker-compose**, incluyendo un contenedor de Microsoft SQL Server en la misma red, para verificar el **correcto funcionamiento** del sistema en local.

        - **Herramientas utilizadas**

            - Docker: Para contenerizar la aplicación y sus dependencias.

            - Azure DevOps Pipelines: Pipelines definidos en YAML que automatizan build y despliegues.

            - Git: Control de versiones y activación automática de pipelines según la rama (feature/Pipelines, main).

        - **Estructura del pipeline**

            CI (Build): Se activa al aceptar "Pull Request" de una feature/xxxx a main, clona el repo, construye la imagen Docker, ejecuta tests y la sube al registro.

        - **Despliegue Continuo (CD):**

            - feature/Pipelines → despliegue manual en Desarrollo

            - main → despliegue automático en Preproducción

            - main → despliegue automático en Producción

        - **Flujo de despliegue**

            - Desarrollo: Validación técnica inicial por el técnico DevOps.

            - Preproducción: Validaciones funcionales.

            - Producción: Despliegue final tras revisión y aprobación.

            Este flujo garantiza entregas **seguras, consistentes y automatizadas** en todos los entornos.


---

### VI. Documentación

1. **Fichero README.MD:**
    - **Indicar si el fichero README contiene la siguiente información:**
        - [✔️] Objetivo principal de la aplicación.
        - [✔️] Descripción de las principales funcionalidades.
        - [✔️] Estructura del proyecto.
        - [✔️] Marco tecnológico utilizado (lenguajes, frameworks, bases de datos).
        - [✔️] Instrucciones para el despliegue de la aplicación.
        - [✔️] Guía sobre cómo colaborar en el proyecto (si aplica).
        - [✔️] Licencia de uso del proyecto.
        - [✔️] Otros aspectos funcionales o técnicos relevantes que hayáis documentado.

---

### VII. Retrospectiva y Lecciones Aprendidas

1. **Desafíos:**
    - **¿Cuáles fueron los mayores desafíos técnicos o de gestión que enfrentasteis durante el proyecto?**
        - Nuevo lenguaje de programación (C#) para el equipo.
        - Nueva arquitectura DDD para el equipo.
        - Despliegue en Azure DevOps.
        - Gestión de versiones y repositorios.
        - Trabajo en equipo entre miembros con perfiles diversos.
        - Definición y asignación de tareas.

    - **¿Cómo los superasteis?**
        - Investigando y organizándonos en diferentes grupos de trabajo.
        - Colaborando y compartiendo conocimientos entre los miembros del equipo y otros equipos.
        - Estudio y investigación, probando continuamente los avances.
        - Recibiendo ciertas formaciones en el centro de trabajo.
        - Utilizando y consultando la Inteligencia Artificial.
        - Utilizando la metodología Scrum como método de trabajo, estableciendo mejoras en las Sprint Retrospective.

2. **Logros:**
    - **¿De qué estáis más orgullosos en este proyecto?**
        - Elaboración de un proyecto interesante y divertido.
        - La organización y estructuración de una arquitectura DDD.
        - Buen ambiente de trabajo entre los miembros del equipo.
        - Cumplimiento de los objetivos del proyecto.
        - Esfuerzo colectivo para conseguir un buen producto.

3. **Mejoras:**
    - **Si tuvierais más tiempo, ¿qué mejoraríais o añadiríais a la aplicación?**
        - Funcionalidad de multijugador, de manera que se pueda jugar la misma partida entre varios jugadores.
        - Comodín para recuperar una vida.
        - Compartir la puntuación en redes sociales.
        - Gestión del perfil usuario.
        - Lideres por temática.
4. **Aprendizaje:**
    - **¿Cuáles son las lecciones más importantes que habéis aprendido como equipo y a nivel individual?**
        - La comunicación entre los miembros es imprescindible y necesario a través de los daily.
        - La elaboración y asignación de tareas requiere un conocimiento previo del trabajo que hay que realizar para que se desarrolle adecuadamente.
        - Las decisiones tomadas deben documentarse para ser revisadas en cualquier momento.
        - El buen ambiente, el humor y la colaboración continua entre los miembros genera un entorno de trabajo que facilita el desarrollo de un buen proyecto.

---

